# Обзор проекта "Работа для всех"

> [!NOTE]
> Этот документ предназначен для внутреннего использования и помощи в разработке с Gemini CLI. Основная документация для пользователей и контрибьюторов находится в файле [README.md](README.md).

Этот документ предоставляет краткий обзор проекта, его структуры и ключевых команд для помощи в разработке с использованием Gemini.

## 1. Описание проекта

**Цель:** REST API для поиска вакансий в России, адаптированных для людей с инвалидностью.

**Ключевые технологии:**
- **Бэкенд:** Python, FastAPI
- **База данных:** PostgreSQL
- **ORM:** SQLAlchemy с использованием Alembic для миграций
- **Контейнеризация:** Docker, Docker Compose
- **Аутентификация:** JWT (JSON Web Tokens)

**Архитектура:**
Проект представляет собой REST API с версионированием (`/api/v1/`). Основные эндпоинты включают:
- `/vacancies/`: Поиск и просмотр вакансий.
- `/regions/`: Получение списка регионов РФ.
- `/federal-districts/`: Получение списка федеральных округов.
- `/auth/`: Регистрация и аутентификация пользователей.

Приложение интегрируется с внешними API "Работа России" и "hh.ru" для сбора данных о вакансиях.

**Язык:** Основной язык кодовой базы, комментариев и документации — **русский**.

## 2. Запуск и разработка

Проект рассчитан на запуск в Docker-контейнерах.

### 2.1. Запуск через Docker

1.  **Сборка и запуск контейнеров:**
    ```bash
    docker-compose up --build
    ```
    Эта команда поднимет два сервиса: `db` (PostgreSQL) и `api_service` (приложение FastAPI). При первом запуске API автоматически загружает в базу данных справочники регионов и федеральных округов.

2.  **Остановка контейнеров:**
    ```bash
    docker-compose down
    ```

### 2.2. Локальная разработка (без Docker)

1.  **Установка зависимостей:**
    ```bash
    pip install -r requirements.txt
    ```

2.  **Запуск сервера:**
    Для локального запуска используется `uvicorn` или `hypercorn`.
    ```bash
    hypercorn app.main:app --reload
    ```
    Сервер будет доступен по адресу `http://127.0.0.1:8000`.

### 2.3. Работа с базой данных

Проект использует **Alembic** для управления миграциями базы данных.

- **Применение миграций:**
  Чтобы обновить схему БД до последней версии, выполните:
  ```bash
  alembic upgrade head
  ```

- **Создание новой миграции:**
  После внесения изменений в модели SQLAlchemy (в `app/db/models/`):
  ```bash
  alembic revision --autogenerate -m "Краткое описание изменений"
  ```

## 3. Соглашения по коду

### 3.1. Линтинг и форматирование

Проект использует `ruff` для линтинга.

- **Проверка кода:**
  ```bash
  ruff check .
  ```

### 3.2. Конфигурация

Конфигурация проекта управляется через переменные окружения, которые загружаются из файла `.env` с помощью Pydantic Settings (`app/core/settings.py`). Для корректной работы необходимо создать и заполнить `.env` файл на основе `.env.example`.

## 4. Структура проекта

- `app/`: Основной исходный код приложения.
  - `api/v1/`: Эндпоинты API.
  - `core/`: Ключевые настройки и конфигурация (FastAPI, логгер, rate limiter).
  - `db/`: Все, что связано с базой данных (сессия, модели, миграции Alembic).
  - `repositories/`: Слой для инкапсуляции логики доступа к данным.
  - `services/`: Слой бизнес-логики.
  - `schemas/`: Pydantic-схемы для валидации данных.
  - `clients/`: Клиенты для взаимодействия с внешними API.
- `alembic.ini`: Конфигурация Alembic.
- `docker-compose.yml`: Определение сервисов для Docker.
- `Dockerfile`: Инструкции по сборке Docker-образа приложения.
- `requirements.txt`: Список зависимостей Python.
- `pyproject.toml`: Конфигурация `ruff`.

## 5. Шаблоны исключений

В проекте принята стандартизированная система кастомных исключений. Используйте эти шаблоны для создания новых классов исключений в соответствующих слоях приложения.

### 5.1. Слой репозиториев (`repositories`)

Используйте этот шаблон для ошибок, связанных с доступом к данным (например, ошибки базы данных).

**Шаблон:**
```python
from fastapi import status

# Замените [EntityName] на имя сущности, например, User, Vacancy.
class [EntityName]RepositoryError(Exception):
    """Базовое исключение для ошибок репозитория [EntityName]."""
    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

    def __init__(self, error_details: str):
        self.error_details = error_details
        super().__init__(self.error_details)

    def __str__(self) -> str:
        return f"An error occurred in the [EntityName]Repository. Details: {self.error_details}"

    @property
    def detail(self) -> str:
        # Оставьте сообщение об ошибке обобщенным для безопасности.
        return f"A database error occurred while processing [entity name] data. Details: {self.error_details}"
```

### 5.2. Слой сервисов (`services`)

Используйте для ошибок на уровне бизнес-логики.

**Шаблон:**
```python
from fastapi import status

# Замените [ServiceName] на название сервиса, например, Vacancies, Users.
class [ServiceName]ServiceError(Exception):
    """Общий класс исключений для [ServiceName]Service."""
    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

    def __init__(self, error_details: str):
        self.error_details = error_details
        super().__init__(self.error_details)

    def __str__(self) -> str:
        return f"An error occurred in the [ServiceName] service. Details: {self.error_details}"

    @property
    def detail(self) -> str:
        return f"An error occurred while processing your request. Details: {self.error_details}"
```

### 5.3. Слой клиентов API (`clients`)

Используйте при ошибках взаимодействия с внешними API.

**Шаблон:**
```python
from pprint import pformat
from fastapi import status

# Замените [ExternalAPI] на название внешнего API, например, HH, TrudVsem.
class [ExternalAPI]APIRequestError(Exception):
    """Ошибка при обращении к API '[ExternalAPI]'."""
    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

    def __init__(self, error_details: str, request_url: str, request_params: dict = {}):
        self.error_details = error_details
        self.request_params = request_params
        self.request_url = request_url
        super().__init__(self.error_details, self.request_params, self.request_url)
    
    def __str__(self) -> str:
        return (
            f"API request to '[ExternalAPI]' failed. URL: {self.request_url}. "
            f"Params: {pformat(self.request_params)}. Details: {self.error_details}"
        )

    @property
    def detail(self) -> str:
        return f"An error occurred while requesting the '[ExternalAPI]' API. Details: {self.error_details}"
```

## 6. Шаблон обработчика эндпоинта

Все обработчики эндпоинтов в `app/api/v1/endpoints/` должны соответствовать этому шаблону для обеспечения консистентности, читаемости и автоматической генерации документации.

### 6.1. Структура

```python
from typing import Annotated
from fastapi import APIRouter, Query, status, HTTPException
from app.core.config_logger import logger
# Импортируйте зависимости, схемы, ошибки и сервисы
from app.dependencies.services import [ServiceName]ServiceDep
from app.schemas.[entity_name] import [ResponseSchema]
from app.services.[entity_name] import [ServiceName]ServiceError
from app.repositories.[entity_name] import [EntityName]RepositoryError

router = APIRouter()

@router.get(
    path="/path",  # Замените на нужный путь
    status_code=status.HTTP_200_OK,
    summary="Краткое описание эндпоинта",
    description="Развернутое описание того, что делает эндпоинт.",
    responses={
        200: {"description": "Успешный ответ."},
        404: {"description": "Ресурс не найден."},
        500: {"description": "Внутренняя ошибка сервера."},
    },
    response_model=[ResponseSchema],
)
async def get_[entity_name_plural](
    service: [ServiceName]ServiceDep,
    # Описывайте параметры с помощью Annotated и Query/Path/Body
    param: Annotated[str, Query(description="Описание параметра.")]
):
    """
    Краткое описание функции.

    Args:
        service: Зависимость, предоставляющая доступ к бизнес-логике.
        param: Описание параметра.

    Returns:
        Объект, соответствующий схеме [ResponseSchema].
    
    Raises:
        HTTPException: В случае возникновения ошибки (например, 404 или 500).
    """
    logger.info("Начало обработки запроса к /path с параметром: %s", param)
    try:
        # Вызов метода сервиса
        result_data = await service.get_data_by_param(param=param)
        logger.info("Успешное завершение обработки /path.")
        return result_data
    except ([EntityName]RepositoryError, [ServiceName]ServiceError) as error:
        # Логирование с максимальным количеством контекста
        logger.error(
            "Ошибка при обработке запроса /path с параметром %s: %s",
            param,
            error,
        )
        # Проброс стандартизированной ошибки
        raise HTTPException(status_code=error.status_code, detail=error.detail)

```

### 6.2. Ключевые моменты

1.  **Документация в декораторе**:
    - `summary`: Краткое, но емкое описание. Видно в общем списке эндпоинтов в Swagger UI.
    - `description`: Подробное описание.
    - `responses`: Обязательно описывайте как минимум успешный ответ (200/201) и возможные ошибки (4xx, 5xx).
    - `response_model`: Указывайте схему Pydantic для тела ответа.

2.  **Документация в Docstring**:
    - Следуйте стилю Google. Описывайте `Args` (аргументы), `Returns` (возвращаемое значение) и `Raises` (выбрасываемые исключения).

3.  **Зависимости и параметры**:
    - Используйте `Annotated` для явного определения типов и метаданных параметров (`Query`, `Path`, `Body`).
    - Сервисы должны инжектироваться через систему зависимостей FastAPI (`[ServiceName]ServiceDep`).

4.  **Логирование**:
    - Логируйте начало обработки запроса с ключевыми параметрами (`logger.info`).
    - В случае ошибки логируйте ее с максимальным количеством контекста, который поможет в отладке (`logger.error`).

5.  **Обработка ошибок**:
    - Весь код, который может вызвать ошибку, оборачивайте в блок `try...except`.
    - Отлавливайте **конкретные** кастомные исключения (`[EntityName]RepositoryError`, `[ServiceName]ServiceError`).
    - Возвращайте клиенту стандартизированный ответ, используя `HTTPException`. `status_code` и `detail` берите из отловленного исключения.

## 7. Задачи для следующих итераций

### 7.1. Обработка дубликатов при добавлении в избранное

**Проблема:**
При попытке пользователя добавить одну и ту же вакансию в избранное несколько раз, приложение падает с ошибкой `sqlalchemy.exc.IntegrityError`, так как срабатывает ограничение уникальности в базе данных. Это приводит к ответу `500 Internal Server Error`, хотя с точки зрения пользователя это не является критической ошибкой.

**Варианты решения:**

1.  **Проверять перед добавлением (Check-then-Act):** Перед тем как выполнить `INSERT`, делать `SELECT` запрос, чтобы проверить, существует ли уже такая запись в таблице избранного для данного пользователя.
2.  **Обрабатывать исключение (Act-then-Handle):** Не делать предварительную проверку, а сразу выполнять `INSERT`. Ошибку `IntegrityError` от SQLAlchemy перехватывать в блоке `try...except` и обрабатывать как штатную ситуацию (например, возвращать клиенту сообщение, что вакансия уже в избранном).

**Рекомендация:**

Предпочтительным является **второй вариант (обрабатывать исключение)**. Этот подход, известный в Python как **EAFP** ("Easier to Ask for Forgiveness than Permission"), имеет несколько преимуществ:
-   **Производительность:** В большинстве случаев (при первом добавлении) выполняется только один запрос к БД (`INSERT`) вместо двух (`SELECT` + `INSERT`).
-   **Атомарность:** Подход "проверь-потом-добавь" уязвим для состояния гонки (race condition), когда два одновременных запроса могут пройти проверку и оба попытаются сделать запись. Обработка исключения на уровне БД лишена этого недостатка.
-   **Чистота кода:** Логика добавления остается простой (`session.add(...)`), а обработка редкого случая (дубликат) выносится в блок `except`.

## 8. План реализации UI (Пользовательского интерфейса)

Этот раздел описывает план поэтапной разработки пользовательского интерфейса для проекта с использованием фреймворка **Dash**.

### 8.1. Технологический стек и основные принципы

-   **Фреймворк:** `Dash`
-   **Библиотека компонентов:** `dash-bootstrap-components` для обеспечения стилизации и доступности компонентов "из коробки".
-   **Интеграция:** Dash-приложение будет смонтировано внутри основного приложения FastAPI (`app/main.py`), что позволит запускать UI и API в рамках одного процесса.
-   **Принципы:**
    -   **Простота:** Интерфейс должен быть интуитивно понятным и не перегруженным.
    -   **Доступность (Accessibility):** Использование семантически верных компонентов, меток для полей ввода и следование практикам WCAG для удобства пользователей с программами экранного доступа.
    -   **Многостраничность:** Навигация будет организована с помощью `dcc.Location` и колбэков для отображения разных страниц (`/`, `/vacancies`, `/login` и т.д.).

### 8.2. План реализации по этапам

#### Этап 1: Базовая структура и главная страница

1.  **Настройка проекта:**
    -   Добавить `dash`, `dash-bootstrap-components` в `requirements.txt`.
    -   Создать новый каталог `app/ui/` для файлов интерфейса.
    -   Создать основной файл `app/ui/layout.py` для общей структуры (шапка, подвал, область для контента) и `app/ui/callbacks.py`.
    -   В `app/main.py` добавить код для монтирования Dash-приложения.

2.  **Главная страница (поиск вакансий):**
    -   **Путь:** `/`
    -   **Компоненты:**
        -   Заголовок: "Поиск вакансий для всех".
        -   Форма поиска, состоящая из:
            -   Выпадающий список "Федеральный округ" (данные из `/api/v1/federal-districts/list`).
            -   Выпадающий список "Регион" (динамически обновляется при выборе округа, данные из `/api/v1/regions/by-federal-districts`).
            -   Текстовое поле "Населенный пункт".
            -   Кнопка "Найти вакансии".
    -   **Логика:**
        -   При нажатии на кнопку "Найти вакансии" отправляется POST-запрос на `/api/v1/vacancies/search`.
        -   Отображается уведомление о том, что поиск запущен (например, "Найдено и сохранено N вакансий. Теперь вы можете просмотреть их.").
        -   После успешного поиска пользователь перенаправляется на страницу со списком вакансий.

#### Этап 2: Страницы со списками и детальной информацией

1.  **Страница со списком вакансий:**
    -   **Путь:** `/vacancies`
    -   **Компоненты:**
        -   Заголовок, отображающий текущий населенный пункт.
        -   Список вакансий, представленный в виде карточек или таблицы. Каждая запись должна содержать: `должность`, `зарплату`, `работодателя`, `адрес`.
        -   Каждая запись является ссылкой на страницу детальной информации о вакансии.
        -   Компонент пагинации для переключения между страницами (использует GET-запрос к `/api/v1/vacancies/list`).
    -   **Логика:** При загрузке страницы выполняется запрос для получения первой страницы вакансий для населенного пункта, указанного на главной.

2.  **Страница с детальной информацией о вакансии:**
    -   **Путь:** `/vacancies/<vacancy_id>`
    -   **Компоненты:**
        -   Полное описание вакансии: `должность`, `зарплата`, `работодатель`, `описание`, `требования`, `контактная информация`.
        -   Кнопка "Добавить в избранное" (видна только для авторизованных пользователей).
    -   **Логика:** При загрузке страницы выполняется GET-запрос к `/api/v1/vacancies/{vacancy_id}`.

#### Этап 3: Аутентификация и личный кабинет

1.  **Навигация и состояние:**
    -   В шапке сайта должны быть ссылки "Войти" и "Регистрация".
    -   Для авторизованных пользователей эти ссылки меняются на "Избранное" и "Выйти".

2.  **Страница регистрации:**
    -   **Путь:** `/register`
    -   **Компоненты:** Форма с полями `username`, `email`, `password`.
    -   **Логика:** Отправляет POST-запрос на `/api/v1/auth/register`. После успешной регистрации показывает сообщение о необходимости проверить почту и перенаправляет на страницу верификации.

3.  **Страница верификации Email:**
    -   **Путь:** `/verify-email`
    -   **Компоненты:** Форма с полями `email` и `code`.
    -   **Логика:** Отправляет POST-запрос на `/api/v1/auth/verify-email`. При успехе сохраняет токены (в `dcc.Store` в браузере) и перенаправляет на главную.

4.  **Страница входа:**
    -   **Путь:** `/login`
    -   **Компоненты:** Форма с полями `email`, `password`. Ссылки на "Забыли пароль?" и "Отправить код повторно".
    -   **Логика:** Отправляет POST-запрос на `/api/v1/auth/login`. При успехе сохраняет токены и перенаправляет на главную.

5.  **Процесс восстановления пароля:**
    -   Реализовать страницы для `/forgot-password` и `/reset-password`.

#### Этап 4: Функциональность для авторизованных пользователей

1.  **Страница "Избранное":**
    -   **Путь:** `/favorites`
    -   **Компоненты:**
        -   Список избранных вакансий, аналогичный общему списку, но с кнопкой "Удалить из избранного" для каждой записи.
        -   Пагинация.
    -   **Логика:**
        -   При загрузке делает GET-запрос к `/api/v1/favorites/list`, используя токен доступа.
        -   Кнопка "Добавить в избранное" на странице вакансии отправляет POST-запрос на `/api/v1/favorites/add-vacancy/{vacancy_id}`.
        -   Кнопка "Удалить из избранного" отправляет POST-запрос на `/api/v1/favorites/delete-vacancy/{vacancy_id}`.

2.  **Выход из системы:**
    -   Кнопка "Выйти" в шапке.
    -   **Логика:** Отправляет POST-запрос на `/api/v1/auth/logout`, очищает сохраненные токены и перенаправляет на главную страницу.

## 9. Модели данных (SQLAlchemy)

Этот раздел описывает модели данных, используемые в проекте, а также устанавливает правила и соглашения для создания новых моделей.

### 9.1. Соглашения по созданию моделей

Для поддержания чистоты кода и консистентности схемы данных все новые модели SQLAlchemy должны создаваться в соответствии со следующими правилами:

1.  **Наследование:** Все конкретные модели должны наследовать от общего декларативного базового класса `app.db.models.base.Base`. Для переиспользования полей между моделями следует создавать абстрактные классы (например, `BaseVacancy`), которые также наследуют от `Base` и содержат атрибут `__abstract__ = True`.

2.  **Именование:**
    *   **Имя класса:** В стиле PascalCase (например, `FavoriteVacancies`).
    *   **Имя таблицы (`__tablename__`):** Во множественном числе, в стиле snake\_case (например, `favorite_vacancies`).

3.  **Документирование (ОБЯЗАТЕЛЬНО):** Каждая модель и каждое ее поле должны быть документированы.
    *   **Класс модели:** Должен содержать русскоязычный docstring, описывающий назначение модели.
    *   **Колонки (`mapped_column`):** Каждое поле **обязательно** должно содержать два атрибута для документации:
        *   `doc`: Краткое описание для разработчика. Поясняет назначение поля в коде Python.
        *   `comment`: Развернутое описание для схемы БД. Этот комментарий будет виден в инструментах администрирования баз данных (DBeaver, DataGrip).

4.  **Метод `__repr__`:** Каждая модель должна реализовывать метод `__repr__` для удобства отладки. Формат: `<ClassName(key='value', ...)>`.

5.  **Отношения:** Внешние ключи (`ForeignKey`) должны быть определены явно. Для каскадного удаления следует использовать `ondelete='CASCADE'`.

**Пример идеальной колонки:**
```python
name: Mapped[str] = mapped_column(
    String(100),
    nullable=False,
    doc='Краткое описание для Python.',
    comment='Развернутое описание, которое попадет в БД.'
)
```

### 9.2. Описание существующих моделей

#### Базовые и абстрактные модели
- **`Base`**: (`app.db.models.base`) Основной декларативный класс, от которого наследуются все модели проекта.
- **`BaseVacancy`**: (`app.db.models.base_vacancy`) Абстрактная модель, содержащая общий набор полей для всех сущностей, связанных с вакансиями. Не создает собственную таблицу в БД.

#### Аутентификация и пользователи
- **`User`**: (таблица `users`) Хранит основную информацию о пользователях: email, хеш пароля, флаги активности и верификации.
- **`BlockedToken`**: (таблица `blocked_tokens`) Черный список для JWT-токенов, которые были аннулированы (например, при выходе пользователя из системы).
- **`EmailVerificationCode`**: (таблица `email_verification_codes`) Временные коды для подтверждения адреса электронной почты.
- **`PasswordResetCode`**: (таблица `password_reset_codes`) Временные коды для сброса пароля.

#### Справочники
- **`Region`**: (таблица `regions`) Справочник регионов России. Содержит коды для разных сайтов-агрегаторов (hh.ru, Работа России).
- **`FederalDistricts`**: (таблица `federal_districts`) Справочник федеральных округов России.

#### Основные сущности
- **`Vacancies`**: (таблица `vacancies`) Основная таблица для хранения всех вакансий, собранных из внешних источников.
- **`FavoriteVacancies`**: (таблица `favorite_vacancies`) Таблица для хранения избранных вакансий пользователей. Связывает пользователя (`user_id`) с вакансией.